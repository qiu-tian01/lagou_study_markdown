能在O(1)的时间复杂度内完成查找动作的数据结构，只有**字典类型**



**数据处理的基本操作**

思考顺序：

1. 分析这段代码到底对数据先后进行了哪些操作
2. 根据分析出来的数据操作，找到合理的数据结构



数据处理的基本操作只有3个，分别是**增**，**删**，**查**

- **增**和**删**可以细分为在数据结构中间的增和删，以及在数据结构最后的增和删，区别就在于原数据的位置是否发生改变
- 差砸后可以四份为按照位置条件的查找和按照数值特性的查找



#### 04. 如何完成线性表结构下的增删查

**数据结构**就是数据的组织方式。

**什么是线性表**

​	线性表是n个数据元素的有限序列，最常用的是链式表达，通常叫做**线性链表**或**链表**



在链表中存储的数据元素叫做**结点**，一个结点存储的就是一条数据记录。



链表在新增，删除数据都可以在O(1)的时间复杂度内完成

对于查找，不管是按照位置的查找还是按照数据条件的查找，都需要对全部数据进行遍历，就是O(n)的时间复杂度



线性表的真正的价值在于，它对数据的存储方式是按照顺序的存储

- 如果数据元素个数不确定，且需要经常进行数据的新增和删除时，链表比较合适
- 如果数据元素大小确定，删除插入的操作并不多，那么用数组更合适



##### 总结

1. 线性链表结构的每个结点，由数据的数值和指向下一个元素的指针构成
2. 除了单向链表还有双向链表，循环链表以及双向循环链表等变形
3. 链表在增，删方面比较容易实现，可以在O(1)的时间复杂度内完成
4. 对于查找，需要对全部数据进行遍历。
5. 线性表的价值在于，它对数据的存储方式是按照顺序的存储
6. 当数据的元素个数不确定，且需要经常进行数据饿的新增和删除时，链表会比较合适
7. **链表的翻转**，**快慢指针的方法**，是必须掌握的内容

**问题**

1. 反转链表

   ```js
   //定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
   /*
   	示例:
   
       输入: 1->2->3->4->5->NULL
       输出: 5->4->3->2->1->NULL
    
   */
   
   /**
    * Definition for singly-linked list.
    * function ListNode(val) {
    *     this.val = val;
    *     this.next = null;
    * }
    */
   /**
    * @param {ListNode} head
    * @return {ListNode}
    */
   
   // 解法一 ： 迭代
   var reverseList = function(head) {
     [cur,pre] = [head,null]
     while(cur){
       [cur.next,cur,pre] = [pre,cur.next,cur]
     }
     return pre
   };
   
   // 解法二：递归
   var reverseList = function(head) {
     if (!head || !head.next) { // 这里是递归的结束条件，最终会到原链表的最后一个节点
       return head
     }
     let newList = reverseList(head.next)
     let cur = head.next
     cur.next = head // 这里就是 head 的下一个节点指向head ，就是5.next = 4
     //防止链表循环，需要将head.next设置为空
     head.next = null
     //每层递归函数都返回cur，也就是最后一个节点
     return newList;
   };
   ```

   ![image-20200921160253507](C:\Users\邱添\AppData\Roaming\Typora\typora-user-images\image-20200921160253507.png)

2. 



#### 05. 栈

展示一种特殊的线性表，栈与线性表不同的地方体现在增和删的操作，具体为栈的数据特点必须是先进后出，后进先出。

栈是后进先出的线性表。



#### 为什么使用栈

在功能上讲链表与数组可以替代栈，但是数组和链表的操作过于灵活，当数据量很大的时候就会出现一些隐藏的风险。

虽然栈限定降低了操作灵活性，但使得栈在处理只涉及一端新增和删除数据的问题时效率更高。



#### 栈是什么

栈包含表头和表尾，在栈结构中，由于操作的特殊性，会对表头表头和表尾的名字进行改造

- 表尾用来输入输出数据，通常叫做栈顶（top）
- 表头是栈底（bottom）

栈顶和栈底是用来表示这个栈的两个指针

栈也有顺序表示和链式表示，分别叫顺序栈与链栈。



存入数据时叫做push，也叫做压栈，移除数据时叫做pop，也叫做出栈。



#### 顺序栈

栈的顺序存储可以借助数组来实现。一般来说，会把数组的首元素存在栈底，最后一个元素放在栈顶。然后定义一个 top 指针来指示栈顶元素在数组中的位置。假设栈中只有一个数据元素，则 top = 0。一般以 top 是否为 -1 来判定是否为空栈。当定义了栈的最大容量为 StackSize 时，则栈顶 top 必须小于 StackSize。

- 当新增元素时将元素放入栈顶，并将栈顶指针加1
- 删除元素时，top-1
- 对于查找操作，栈没有额外的改变，跟线性表一样，它也需要遍历整个栈来完成基于某些条件的数值查找。



#### 链栈

关于链式栈，就是用链表的方式对栈的表示。通常，可以把栈顶放在单链表的头部。



#### 总结

- 栈具有后进先出的特性，当面对的问题需要高频使用新增，删除操作。且新增和删除操作的数据执行顺序执行顺序具备后来居上的相反关系时，栈是一个不错的选择，例如浏览器的前进和后退，括号匹配等问题。
- 栈继承了线性表的优点与不足，是个限制版的线性表。限制的功能是，只允许数据从栈顶进出，这也就是栈后进先出的性质。不管是顺序栈还是链式栈，它们对于数据的新增操作和删除操作的时间复杂度都是 O(1）。而在查找操作中，栈和线性表一样只能通过全局遍历的方式进行，也就是需要 O(n) 的时间复杂度。



### 06. 队列

队列也是一种特殊的线性表，与线性表的不同也是体现在对数据的增加和删除的操作上

- 队列只能在队尾新增数据，而只能对队头删除数据
- 队列也存在两种存储方式，即顺序队列与链式队列
  - 顺讯队列：依赖数组来实现，其中数据在内存中也是顺序存储
  - 链式队列：依赖链表来实现，其中的数据依赖一个结点的指针互联，在内存中并不是顺序存储链式队里，实际上就是只能尾进头出的线性表的单链表



#### 循环队列

数组越界问题可以通过队列的一个特殊变种来解决，叫做循环队列

循环队列进行新增数据袁术操作时，首先判断队列是否为满

如果不满，则可以将新元素赋值给队尾，然后让rear指针向后移动一个位置

如果已经排到队列最后的位置，则rea指针重新指向头部

当队列为空时，有 front 指针和 rear 指针相等。而现在的队列是满的，同样有 front 指针和 rear 指针相等。那么怎样判断队列到底是空还是满呢？常用的方法是，设置一个标志变量 flag 来区别队列是空还是满。

#### 链式队列

链式队列就是一个单链表，同时增加了 front 指针和 rear 指针。链式队列和单链表一样，通常会增加一个头结点，并另 front 指针指向头结点。头结点不存储数据，只是用来辅助标识。



#### 总结 ：

1. 在时间复杂度上，循环队列和链式队列的新增、删除操作都为 O(1)。
2. 在查找操作中，队列和线性表一样只能通过全局遍历的方式进行，也就是需要 O(n) 的时间复杂度。
3. 在空间性能方面，循环队列必须有一个固定的长度，因此存在存储元素数量和空间的浪费问题，而链式队列不存在这种问题，所以在空间上，链式队列更为灵活一些。
4. 通常情况下，在可以确定队列长度最大值时，建议使用循环队列。
5. 无法确定队列长度时，应考虑使用链式队列。

​	

### 07 数组

- 栈和队列是特殊的线性表，本质上他们都可以被看做是一类基本结构
- 数组可以看成是线性表的一种推广，它属于另外一种基本的数据结构



- 数组是数据结构中最基本结构，几乎所有的程序设计语言都把数组类型设定为固定的基础变量类型，可以把数组理解为一种容器，它可以用来存放若干个相同类型的数据元素



**数组的基本操作**

数组在存储数据时是按顺序存储的，并且存储数据的内存也是连续的，这就造成了它具有增删困难、查找容易的特点。同时，栈和队列是加了限制的线性表，只能在特定的位置进行增删操作。相比之下，数组并没有这些限制，可以在任意位置增删数据，所以数组的增删操作会更为多样。下面我们来具体地介绍一下数组的增删查操作。

**数组的新增操作**
数组新增数据有两个情况：

第一种情况，在数组的最后增加一个新的元素。此时新增一条数据后，对原数据产生没有任何影响。可以直接通过新增操作，赋值或者插入一条新的数据即可。时间复杂度是 O(1)。

第二种情况，如果是在数组中间的某个位置新增数据，那么情况就完全不一样了。这是因为，新增了数据之后，会对插入元素位置之后的元素产生影响，具体为这些数据的位置需要依次向后挪动 1 个位置。

**数组的删除操作**
数组删除数据也有两种情况：

第一种情况，在这个数组的最后，删除一个数据元素。由于此时删除一条数据后，对原数据没有产生任何影响。我们可以直接删除该数据即可，时间复杂度是 O(1)。

第二种情况，在这个数组的中间某个位置，删除一条数据。同样的，这两种情况的区别在于，删除数据之后，其他数据的位置是否发生改变。由于此时的情况和新增操作高度类似，我们就不再举例子了。

**数组的查找操作**
相比于复杂度较高的增删操作，数组的查找操作就方便一些了。由于索引的存在，数组基于位置的查找操作比较容易实现。我们可以索引值，直接在 O(1) 时间复杂度内查找到某个位置的元素。

**数组增删查操作的特点**
通过以上内容的学习，我们发现数组增删查的操作相比栈、队列来说，方法更多，操作更为灵活，这都是由它们数据结构的特点决定的。接下来，我们来归纳一下数组增删查的时间复杂度。

- 增加：若插入数据在最后，则时间复杂度为 O(1)；如果中间某处插入数据，则时间复杂度为 O(n)。


- 删除：对应位置的删除，扫描全数组，时间复杂度为 O(n)。


- 查找：如果只需根据索引值进行一次查找，时间复杂度是 O(1)。但是要在数组中查找一个数值满足指定条件的数据，则时间复杂度是 O(n)。


实际上数组是一种相当简单的数据结构，其增删查的时间复杂度相对于链表来说整体上是更优的。那么链表存在的价值又是什么呢？

- 首先，链表的长度是可变的，数组的长度是固定的，在申请数组的长度时就已经在内存中开辟了若干个空间。如果没有引用 ArrayList 时，数组申请的空间永远是我们在估计了数据的大小后才执行，所以在后期维护中也相当麻烦。


- 其次，链表不会根据有序位置存储，进行插入数据元素时，可以用指针来充分利用内存空间。数组是有序存储的，如果想充分利用内存的空间就只能选择顺序存储，而且需要在不取数据、不删除数据的情况下才能实现。



### 08 字符串 

#### 字符串是什么

- 字符串（string） 是由 n 个字符组成的一个有序整体（ n >= 0 ）

- 字符串的逻辑结构和线性表很相似，不同之处在于字符串针对的是字符集，也就是字符串中的元素都是字符，线性表则没有这些限制。

在实际操作中，我们经常会用到一些特殊的字符串：

- 空串，指含有零个字符的串。例如，s = ""，书面中也可以直接用 Ø 表示。


- 空格串，只包含空格的串。它和空串是不一样的，空格串中是有内容的，只不过包含的是空格，且空格串中可以包含多个空格。例如，s = "   "，就是包含了 3 个空格的字符串。


- 子串，串中任意连续字符组成的字符串叫作该串的子串。


- 原串通常也称为主串。例如：a = "BEI"，b = "BEIJING"，c = "BJINGEI" 。

  - 对于字符串 a 和 b 来说，由于 b 中含有字符串 a ，所以可以称 a 是 b 的子串，b 是 a 的主串；

  - 而对于 c 和 a 而言，虽然 c 中也含有 a 的全部字符，但不是连续的 "BEI" ，所以串 c 和 a 没有任何关系。



#### 总结

字符串的逻辑结构和线性表极为相似，区别仅在于串的数据对象约束为字符集。但是，字符串的基本操作和线性表有很大差别：

- 在线性表的基本操作中，大多以“单个元素”作为操作对象；


- 在字符串的基本操作中，通常以“串的整体”作为操作对象；


- 字符串的增删操作和数组很像，复杂度也与之一样。但字符串的查找操作就复杂多了，它是参加面试、笔试常常被考察的内容。