### 01javaScript性能优化

- 内存管理
- 垃圾回收机制与常见GC算法
- V8引擎的垃圾回收
- Performance工具



### 02内存管理

- 内存：由可读写单元组成，表示一片可操作性空间
- 管理：人为的操作一片空间的申请，使用和释放
- 内存管理：开发者主动申请空间，使用空间，释放空间
- 管理流程：申请--使用--释放



js中的内存管理

- 申请内存空间
- 使用内存空间
- 释放内存空间

```js
//申请
let obj = {}

//使用
obj.name = 'qt'

//释放
obj = null
```



### 03js中的垃圾回收

- js中内存管理是自动的，，当我们创建数组，对象，变量时会自动分配内存空间
- 对象不再被引用时是垃圾
- 对象不能从根上访问到时是垃圾



js中的可达对象

- ​	可以访问到的对象就是可达对象（引用，作用域链）
- 可达的标准就是从根触发是否能够被找到
- js中的根就可以理解为时全局变量对象(全局执行上下文)



### 04 GC算法介绍

- GC就是垃圾回收机制的简写
- GC可以找到内存中的垃圾，并释放和回收空间



GC库的垃圾是什么

- 程序中不在需要使用对象
- 程序中不再需要使用对象



GC算法是什么

- GC是一种机制，垃圾回收完成具体的工作
- 工作的内容就是查找垃圾释放空间，回收空间
- 算法就是工作时查找和回收所遵循的规则



常见Gc算法

- 引用计数
- 标记清除
- 标记整理
- 分代回收



### 05 引用计数算法实现原理

- 核心思想：设置引用数：判断当前引用数是否为0
- 引用计数器
- 引用关系改变时修改引用数字
- 引用数字为0时立即回收

```js
const user1 = {age :1}
const user2 = {age :2}
const user3 = {age :3}
const nameList = [user1.age,user2.age,user3.age]

function fn(){
    const num1 = 1;
    const num2 = 2;
}//当函数执行完成后，num1，num2引用为0，引用计数器会回收空间

fn（)
```



### 06 引用计数算法优缺点

- 优点
  - 发现垃圾时立即回收
  - 最大限度减少程序暂停
- 缺点
  - 无法回收循环引用的对象
  - 时间开销大



对象中的循环引用

```js
//变量的循环引用

function fn() {
    const obj1 = {}
    const obj2 = {}
    //全局作用域下找不到obj1，obj2，但是obj1.name,obj2.name还引用着，所以引用数不为0
    obj1.name = obj2;
    obj2.name = obj1

    return 'xxxx'
}

fn()
```



### 07标记清除算法实现原理

- 核心思想 ： 分为标记和清除两个阶段完成
  - 第一步：遍历所有对象找标记活动对象
  - 第二步：遍历所有对象清除没有标记对象



标记计数时会递归的查找引用层级关系，把可达对象进行标记。

将回收的空间放在空闲列表上面，方便后面的程序直接在这里申请内存使用。



### 08标记清除算法的优缺点

- 优点：
  - 解决对象循环引用不能回收的问题(相对于引用计数)
- 缺点：
  - 空间碎片化（由于回收的空间地址不连续），不能使空间最大化使用
  - 不会立即清除垃圾



### 09 标记整理算法实现原理

- 标记整理可以看做是标记清除的增强
- 标记阶段的操作和标记清除算法一致
- 清除阶段会先执行整理，移动对象位置
- 优点：
  - 减少碎片空间化
- 缺点：
  - 不会立即回收垃圾对象



### 10 常见GC算法

- 引用计数
- 标记清除
- 标记整理



### 11认识V8

- V8是一款主流的js执行引擎
- V8采用即时编译
- V8内存设置上限
  - 64位不超过1.5G
  - 32位不超过800M



### 12垃圾回收策略

​	程序使用过程中会用到很多数据，这些数据可分为原始数据和对象类型数据，对于原始数据都是由语言自身来控制的。所以回收指的是堆区里面的对象类型数据。



- 采用分代回收的思想
- 内存分为新生代，老生代存储区
- 针对不同对象采用不同算法



V8中常用GC算法

- 分代回收
- 空间复制
- 标记清除
- 标记整理
- 标记增量



V8中的内存是设置上限的，所以要采用分代回收的思想，不同代采用不同的更适合的GC算法



### 13V8垃圾回收新生代对象

- v8内存分配（划分内存空间一分为二）
  - 新生代对象
  - 老生代对象

- 新生代对象
  - 小空间用于存储新生代对象（64位为：32M| 32位为：16M）
  - 新生代指的是存活时间较短的对象



- 新生代对象回收实现

  回收过程采用复制算法+标记整理

  新生代内存区分为两个等大小空间

  - 使用空间为From
  - 空闲控件为To
  - 活动对象存储于From空间
  - 标记整理后将活动对象拷贝至To
  - From与To交换空间完成释放



- 拷贝过程中可能出现晋升
- 晋升就是将新生代对象移动至老生代
- 一轮Gc还存活的新生代需要晋升
- To空间的使用率超过25%，也要讲To中的对象引动到老生代



### 14 V8如何回收老生代对象

- 老生代对象对象存放在右侧老生代区域‘
- 64位操作系统1.4G，32位操作系统700m
- 老生代独享就是指存活时间较长的对象 
  - 全局作用域的对象
  - 闭包



老生代对象回收实现

- ​	主要采用标记清除，标记整理，增量标记算法
- 首先使用标记清除完成垃圾空间的回收
- 采用标记整理进行空间优化
- 采用增量标记进行效率优化



与新生代区域对比

- 新生代区域垃圾回收使用空间换时间
- 老生代区域垃圾回收不合适复制算法



### 15 Performance工具介绍

- GC的目的是为了实现内存空间的良性循环
- 良性循环的基石是合理使用
- 时刻关注才能确定是否合理
- PerFormance提供多种监控方式



使用步骤：

1. 打开浏览器输入目标网址
2. 进入开发人员工具面板，选择性能
3. 开启录制功能，访问具体页面
4. 执行用户行为，一段时间后停止录制
5. 分析界面中记录的内存信息



### 16内存问题的体现

内存问题的外在表现

- 页面出现延迟加载或经常性暂停（频繁的垃圾回收）
- 页面持续性出现糟糕的性能（内存膨胀）
- 页面的性能随时间延长越来越差（内存泄漏）



### 17监控内存的几种方式

- 内存泄漏：内存使用持续升高
- 内存膨胀：在多数设备上存在性能问题
- 频繁垃圾回收：通过内存变化图进行分析



监控内存的几种方式

- 浏览器任务浏览器
- Timeline时序图记录
- 堆快照查找分析DOM
- 判断是否存在频繁的垃圾回收



### 18 任务管理器监控内存

shift+esc调出浏览器任务管理器



### 19Timeline记录内存

使用浏览器中性能中的timeline去定位具体的内存走向



### 20堆快照查找分离DOM

- 界面元素存活在DOM树上
- 垃圾对象时的DOM节点：从当前DOM树上脱离，并且没人引用的DOM节点
- 分离状态的DOM节点：从当前DOM树上脱离，并且有人引用的DOM节点



在浏览器中找到内存面板，选择堆快照



### 21判断是否存在频繁GC

- GC工作时应用程序时停止的
- 频繁且过长的GC会导致应用假死
- 用户使用中感知应用卡顿



确定：

- Timeline中频繁的上升下降
- 任务管理器中数据频繁的增加减少



### 22performance总结

- performance是谷歌浏览器提供的测试工具
- 内存问题的相关分析
- Performance时序图监控内存变化
- 任务管理器监控门内存变化
- 堆快照查找分离DOM



### 23代码优化

如何精准测试JavaScript性能

- 本质上就是采集大量的执行样本进行数学统计和分析
- 使用基于Benchmark.js的https://jsperf.com/完成性能测试
  - 使用Github账号登录
  - 填写个人信息(非必须)
  - 填写详细的测试用例信息(title,slug)
  - 填写准备代码
  - 填写必要有setup与teardown代码
  - 填写测试代码片段



### 24慎用全局变量

- 全局变量定义在全局执行上下文，是所有作用域链的顶端（耗时）
- 全局执行上下文一直存在于上下文执行栈，知道程序退出（对GC工作不利，不回收垃圾）
- 如果某个局部作用域出现了同名变量则会遮蔽或污染全局

```

var  i, str = ''

for(i<0;i<1000;i++){
    str += i
}

for(let i=0 ; i<1000; i++){
    let str = ''
    str += i
}
```



![image-20200602211042050](C:\Users\邱添\AppData\Roaming\Typora\typora-user-images\image-20200602211042050.png)





### 25 缓存全局变量

- 将使用中无法避免的全局变量缓存到局部



### 26通过原型新增方法

- 构造函数
- 原型对象
- 实例对象

实例对象和构造函数指向原型对象

在原型对象上新增实例对象需要的方法



### 27避开闭包陷阱

- 闭包特点
  - 外部具有指向内部的引用
  - 在"外"部作用域访问"内"部作用域的数据
- 闭包使用不当容易出现内存泄漏

```js
function foo() {
    var el = document.getElementById('btn')
    el.onclick = function () {
        console.log(el.id)
    }
    el = null
}
```



### 28 避免属性访问方法使用

- js不需要属性的访问方法，所有属性都是外部可见的
- 使用属性访问方法只会增加一层重定义，没有访问的控制力



### 29For循环优化

```
let arr = [1,2,3,4]
for(let i = 0,len = arr.length;i<len;i++){
	xxx
}
```



 ### 30采用最优循环方式

for循环，forEach，for...in...比较



forEach在单纯遍历数组数据是效率最好的，for循环其次，forIn最后



### 31文档碎片化优化节点添加

- 节点的添加操作必然会有回流和重绘

```
const fragEle = document.createDocumentFragment()
for(let i = 0;i<10;i++){
	let oP = document.createElement('p')
	oP.innerHTML = i
	fragEle.appendChild(oP)
}
document.body.appendChild(oP)
```



### 32克隆优化节点操作

```js
<p id="box1"></p>

let oldp = document.getElementById('box1')
for(let i = 0;i<3;i++){
    let newP = oldP.cloneNode(false)
    newP.innerHTML = i
    document.body.appendChild(newP)
}
```



### 33直变量替换Object操作

```js
//1
var a = [1,2,3]
//2
var a1 = new Array(3)

a1[0] = 1
a1[0] = 2
a1[0] = 3
```

采用a = [1,2,3]



